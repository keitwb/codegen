#!/usr/bin/env python

""" Memoria Code Generator

`templates.yaml` should be an array of dictionaries with the following fields:
- name: the filename of the template in the `templates` folder minus the `.mako` extension
- render_path: the output file of the rendered template
- for_tables: a list of tables that are passed individually to the mako
    template.  If this is present, `name` above will be processed as a mako
    template with the table data as the context.  If this key is not present,
    the template will only be processed once with the tables list as the context 

TODO: Custom sections are not yet supported in languages that do not have a
single "rest of line" comment delimiter (like CSS, which only has `/* */` and no
'//' or '#' like Java or Python/Perl)
"""
import yaml
import os
import sys
import re
from stat import ST_MTIME
from optparse import OptionParser
from mako.template import Template
from mako.lookup import TemplateLookup
from mako import exceptions
from copy import deepcopy

from templates import common

from consolewriter import ConsoleWriter
from beautifier import Beautifier

class TemplateProcessor(object):
    RENDERED_CUSTOM_START_DELIM = '!!!! BEGIN CUSTOM SECTION '
    RENDERED_CUSTOM_END_DELIM = '!!!! END CUSTOM SECTION '
    TEMPLATE_CUSTOM_SECTION = '!!!! CUSTOM SECTION '

    def __init__(self, basedir, schema_file=None, pretty_print=True, force=False):
        self.cw = ConsoleWriter()

        self.options = options
        self.basedir = basedir
        self.template_info_path = os.path.join(basedir, 'codegen/templates.yaml')
        self.tables_path = os.path.join(basedir, 'tables.yaml')

        # Map each list element to a dict entry with `name` as the key
        self.template_info = dict( map( lambda t: (t['name'], t), self.load_yaml(self.template_info_path) ) )
        self.tables = dict( map( lambda t: (t['name'], t), self.load_yaml(self.tables_path) ) )

        # Pull all the vars out of the common module.  A little hacky but seem
        # to work fine
        common_names = filter(lambda x: not re.match('^__', x), dir(common))
        self.common_dict = dict( [ (k, getattr(common, k)) for k in common_names ] )
        self.common_dict['basedir'] = basedir

    def get_custom_sections(self, render_path):
        """
        Pulls out the custom sections of an existing rendered template so they
        can be reinserted in a new rendering.  The return value is a dict whose
        keys are the section identifier and the value is the section text,
        including the delimiters.
        """
        try:
            render_fd = open(render_path, 'r')
        except IOError:
            return dict() 
        contents = render_fd.read()

        custom_sections = re.findall(r'('+self.RENDERED_CUSTOM_START_DELIM
                + r'([\w\d]+)$'  # Opening delim plus identifier
                + r'(.*?)'  # Section text
                + r'^\s*([^\s]*)\s*' + self.RENDERED_CUSTOM_END_DELIM  # end delimiter
                + r')', contents, re.DOTALL | re.MULTILINE);

        render_fd.close()

        section_dict = dict( [(sec[1].strip(), sec[2]) for sec in custom_sections if len(sec[2].strip()) > 0] )

        self.cw.debug('Custom sections found: ' + str(section_dict.keys()))

        return section_dict

    def replace_custom_sections(self, rendered_text, section_dict):
        """
        Replaces the custom text sections of `rendered_text` with the sections
        in `section_dict`
        """
        # All the places marked in the template as a place for custom text
        template_sections = re.findall(r'^((.+)' + self.TEMPLATE_CUSTOM_SECTION + r'([\w\d]+))$', rendered_text, re.MULTILINE)
        for sec in template_sections:
            comment_start = sec[1]
            identifier = sec[2].strip()

            if section_dict.has_key(identifier):
                custom_text = section_dict[identifier]
            else:
                custom_text = '\n'

            rendered_text = re.sub(sec[0],
                    comment_start + self.RENDERED_CUSTOM_START_DELIM + identifier
                    + custom_text
                    + comment_start + self.RENDERED_CUSTOM_END_DELIM
                    , rendered_text) 

        return rendered_text

    def add_banner(self, rendered_text, render_path, template_path):
        ext_to_comment_start = {
            'pm': '#',
            'py': '#',
            'java': '//',
            'sql': '--',
        }

        banner_text = (
            """THIS FILE IS AUTOMATICALLY GENERATED!!!

            Source template: {template_path} 

            Only modifications in the specially marked sections will be preserved by
            the generator.""")

        # Let any exceptions fall up
        ext = render_path.rsplit('.', 1)[1]
        comment_start = ext_to_comment_start[ext]

        # Add in comments and template name
        banner = re.sub('(?m)^[ ]*', comment_start + ' ', banner_text)
        banner = banner.format(template_path=os.path.basename(template_path))

        return banner + '\n' + rendered_text

    def render_mako_template(self, template_path, render_path, **kwargs):
        """
        Renders the template at `template_path` passing `kwargs` to the mako
        render function.  The rendered template is written to `render_path`.
        """
        lu = TemplateLookup(directories=[os.path.join(basedir, 'codegen/templates/')])
        tmpl = Template(filename=template_path, lookup=lu)

        #for k,v in kwargs.items():
        #    setattr(tmpl, k, v)

        dirname = os.path.dirname(render_path)
        if not os.path.exists(dirname):
            os.makedirs(dirname)

        custom_sections = self.get_custom_sections(render_path)
        #print 'existing sections: ' + str(custom_sections)

        try:
            context_dict = dict()
            context_dict.update(deepcopy(self.common_dict))
            context_dict.update(deepcopy(kwargs))
            rendered_text = tmpl.render(**context_dict)

            rendered_text = self.replace_custom_sections(rendered_text, custom_sections)
            rendered_text = self.add_banner(rendered_text, render_path, template_path)

            if self.options.pretty:
                beautifier = Beautifier.by_extension(render_path)
                if beautifier is None:
                    self.cw.error('Skipping pretty print: formatter not found for filetype.')
                else:
                    rendered_text = beautifier.process(rendered_text)

            outfile = open(render_path, 'w')
            outfile.write(rendered_text)
        except:
            print exceptions.text_error_template().render()
        finally:
            try: 
                outfile.close()
            except AttributeError:
                pass

    def need_render(self, template_path, render_path):
        """
        Returns `True` if the file at `render_path` is older than the
        template at `template_path` or if the tables file has been updated.
        """
        template_stat = os.stat(template_path)

        if os.path.exists(render_path) == False:
            return True

        render_stat = os.stat(render_path)
        template_info_stat = os.stat(self.template_info_path)
        models_stat = os.stat(self.tables_path)

        if (template_stat[ST_MTIME] >= render_stat[ST_MTIME] or
            template_info_stat[ST_MTIME] >= render_stat[ST_MTIME] or
            models_stat[ST_MTIME] >= render_stat[ST_MTIME]):
            return True

        print "Skipping: Template older than previous render output..."
        return False

    def load_yaml(self, path):
        fd = open(path, 'r')

        d = yaml.load(fd)

        fd.close()
        return d

    def execute(self, to_render=[], force=False):
        """
        Renders the templates specified in the `to_render` list.

        `force` causes the templates to be re-rendered regardless of
        modification times.
        """
        #if len(to_render) > 0:
            #templates = filter(lambda t: t['name'] in to_render, templates)
        #else:
            #print 'No templates specified'
            #return

        for template_name in to_render:
            t = self.template_info.get(template_name, None)
            if not t:
                self.cw.error('Template not found "%s"' % (template_name))
                continue

            self.cw.output('Processing template: ' + template_name, True)

            template_path = os.path.join(basedir, 'codegen/templates', template_name+'.mako')

            if len(t.get('for_tables', [])) > 0:
                for table_name in t['for_tables']:
                    table = self.tables[table_name]

                    # The path is itself a template to generate the name of each output file
                    path_tmpl = Template(t['render_path'])
                    render_path = os.path.join(basedir, str(path_tmpl.render(**table)))

                    self.cw.output('For table: ' + table['name'], True)

                    if force or self.need_render(template_path, render_path):
                        self.render_mako_template(template_path, render_path, tables=self.tables, **table)

                    self.cw.reset_indent()
            else:
                render_path = os.path.join(basedir, t['render_path'])
                if force or self.need_render(template_path, render_path):
                    self.render_mako_template(template_path, render_path, tables=self.tables)

            self.cw.reset_indent()

    def templates_for_types(self, types):
        """ Gets all the templates that match a specific type.  Right now type
        is determined by the subdir of the project that the template renders to
        (android, webapp, server...)
        """
        templates = []
        for name, template in self.template_info.items():
            for t in types:
                if t in template['render_path'].split('/')[0]:
                    templates.append(name)

        return templates


if __name__ == '__main__':
    os.chdir(os.path.dirname(sys.argv[0]))

    usage = """usage: %prog [options] TEMPLATES...
    Renders the templates in templates.yaml.  TEMPLATES indicates the names of
    the templates to render, if present.  Use the type option (-t) to render all 
    templates of a specific type.
    """
    parser = OptionParser(usage=usage)

    parser.add_option("-d", "--basedir", dest="basedir", default=".",
        help="the base directory of the project")
    #parser.add_option("-t", "--type", dest="types", action="append",
        #help="The type of templates to render (android, server, webapp)")
    parser.add_option("-f", "--force", action="store_true", dest="force",
            default=False, help="force the templates to rerender")
    parser.add_option("-p", "--pretty", action="store_true", dest="pretty",
            default=False, help="run the output through an appropriate code formatter if available")
    parser.add_option("-s", "--schema-file", dest="schema_file", default="schemas.yaml",
            help="filename for the schemas to be used when processing the templates")

    (options, args) = parser.parse_args()

    # Should be the root dir of the app
    basedir = os.path.abspath(options.basedir)
    delattr(options, 'basedir')

    #if schema_file not in os.listdir(basedir):
        #print 'Error: "tables.yaml" not found in base dir: ' + basedir
        #exit(1)

    processor = TemplateProcessor(basedir, options)

    if options.types is not None:
        to_render = processor.templates_for_types(options.types)
        to_render += args
    else: 
        to_render = args

    processor.execute(to_render, options.force)

